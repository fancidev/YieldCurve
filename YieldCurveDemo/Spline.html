<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <title>Hello</title>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jquery-1.11.3.min.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/canvasjs-1.8.0-beta4-mod.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jquery.canvasjs.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/numeric-1.2.6.js"></script>
  
  <script type="text/javascript">
$(function () {
	
	$("#termStructureChart").CanvasJSChart({
		title: {
			text: 'US Swap Rate Term Structure',
			fontSize: 16
		},
		legend: { 
			fontSize: 12,
		},
		axisX: {
			labelFontSize: 12,
			minimum: 0,
			gridThickness: 1,
			gridColor: 'gray',
			gridDashType: 'dash'
		},
		axisY: {
			labelFontSize: 12,
			gridThickness: 1,
			gridColor: 'gray',
			gridDashType: 'dash',
			labelFormatter: function (e) { return CanvasJS.formatNumber(e.value, '0.00'); }
		},
		toolTip: {
			shared: true
		},
		data: [ ]
	});
});

  </script>
  <script type="text/javascript">

	window.onerror = function () { return true; };

	$(document).ready(function () {
		drawTermStructure();
		//drawBezierBasis();
	});
	
	// Plot each row in the table as a series.
	function drawBezierBasis() 
	{
		var chart = $("#termStructureChart").CanvasJSChart();
		var x = [-2,-1,0,  1,2,3,5,7,10,   11,12,13];
		x = [1,1,1,  1,2,3,5,7,10,   10,10,10];
		var np = x.length;
		chart.options.data.length = 0; // clear existing series
		var p = 3;
		for (var i = 0; i < x.length - p - 1; i++)
		{
			var dataPoints = [];
			var xx = [];
			var yy = [];
			for (var t = 1; t <= 10; t+=1/32) {
				xx.push(t);
				yy.push(N(i,p,x,t));
				dataPoints.push({
					x: t, y: N(i,p,x,t)
				});
			}
			chart.options.data.push({
				type: 'line',
				name: 'N_' + i + '^' + p,
				markerType: 'square',
				showInLegend: true,
				dataPoints: dataPoints
			});
		}
		
		for (var i = 0; i < x.length - p - 1; i++)
		{
			var dataPoints = [];
			var xx = [];
			var yy = [];
			for (var t = 1; t <= 10; t+=1/32) {
				xx.push(t);
				yy.push(dN(i,p,x,t,1));
				dataPoints.push({
					x: t, y: dN(i,p,x,t,1)
				});
			}
			chart.options.data.push({
				type: 'line',
				name: 'dN_' + i + '^' + p,
				markerType: 'square',
				showInLegend: true,
				dataPoints: dataPoints
			});
		}
		
		//adjustYAxisLimits(chart);
		chart.render();
	}
	
	// Plot each row in the table as a series.
	function drawTermStructure() 
	{
		var dataPoints = [
			{ x: 1, y: 5.39 },
			{ x: 2, y: 5.21 },
			{ x: 3, y: 5.16 },
			{ x: 4, y: 5.16 },
			{ x: 5, y: 5.18 },
			{ x: 7, y: 5.23 },
			{ x: 10, y: 5.29 },
			{ x: 30, y: 5.41 }
		];
		var degree = 5;
		var XY;
		if (degree == 1) { // linear 
			XY = bsplineInterp(dataPoints, 1, []);
		} else if (degree == 2) { // quadratic, flat rhs deriv
			XY = bsplineInterp(dataPoints, 2, [
				{ knotIndex: -1, derivOrder: 1, derivValue: 0 },
			]);		
		} else if (degree == 3) { // natural cubic spline
			XY = bsplineInterp(dataPoints, 3, [
				{ knotIndex:  0, derivOrder: 2, derivValue: 0 },
				{ knotIndex: -1, derivOrder: 2, derivValue: 0 },
			]);
		} else if (degree == 4) { // quartic spline
			XY = bsplineInterp(dataPoints, 4, [
				{ knotIndex:  0, derivOrder: 2, derivValue: 0 },
				{ knotIndex: -1, derivOrder: 2, derivValue: 0 },
				{ knotIndex: -1, derivOrder: 1, derivValue: 0 },
			]);
		} else if (degree == 5) { // quintic spline
			XY = bsplineInterp(dataPoints, 5, [
				{ knotIndex:  0, derivOrder: 2, derivValue: 0 },
				{ knotIndex: -1, derivOrder: 3, derivValue: 0 },
				{ knotIndex: -1, derivOrder: 2, derivValue: 0 },
				{ knotIndex: -1, derivOrder: 1, derivValue: 0 },
			]);
		} else {
			throw 'Invalid degree';
		}

		
		var chart = $("#termStructureChart").CanvasJSChart();
		chart.options.data.length = 0; // clear existing series
		chart.options.data.push({
			type: 'scatter',
			name: 'Term structure',
			markerType: 'square',
			showInLegend: true,
			dataPoints: dataPoints
		});
		chart.options.data.push({
			type: 'line',
			name: 'Interpolated',
			markerType: 'none',
			showInLegend: true,
			dataPoints: XY
		});
		adjustYAxisLimits(chart);
		chart.render();
		
		return;
		
		var chart = $("#termStructureChart").CanvasJSChart();
		chart.options.data.length = 0; // clear existing series
		chart.options.data.push({
			type: 'line',
			name: '08-SEP-2006',
			markerType: 'square',
			showInLegend: true,
			dataPoints: [
				{ x: 1, y: 5.39 },
				{ x: 2, y: 5.21 },
				{ x: 3, y: 5.16 },
				{ x: 4, y: 5.16 },
				{ x: 5, y: 5.18 },
				{ x: 7, y: 5.23 },
				{ x: 10, y: 5.29 },
				{ x: 30, y: 5.41 }
			]
		});
		adjustYAxisLimits(chart);
		chart.render();
	}
	
	function adjustYAxisLimits(chart)
	{
		var minY = Infinity;
		var maxY = -Infinity;
		var data = chart.options.data;
		for (var i = 0; i < data.length; i++) {
			var dataPoints = data[i].dataPoints;
			for (var j = 0; j < dataPoints.length; j++) {
				var value = dataPoints[j].y;
				minY = Math.min(minY, value);
				maxY = Math.max(maxY, value);
			}
		}
		
		// Adjust the Y-axis range to half-percent with 5bp margin.
		var margin = 0.05;
		var roundTo = 0.50;
		minY = Math.floor((minY - margin) / roundTo) * roundTo;
		maxY = Math.ceil((maxY + margin) / roundTo) * roundTo;
		chart.options.axisY.minimum = minY;
		chart.options.axisY.maximum = maxY;
		
		// Note: the caller must call chart.render() to take effect.
		// chart.render();
	}
	
	// Interpolate a vector of n points
	// { x: 1, y: 5.39 }, { x: 2, y: 5.21 }, ...
	// order:
	//   1 - linear
	//   2 - quadratic spline
	//   3 - cubic spline
	// extraConditions:
	//   An array of extra conditions to impose on the derivative
	//   on selected knot points. The number of conditions must be
	//   equal to (p - 1). Each condition is a named tuple:
	//   {
	//     knotIndex:  = zero-based knot index 
	//     derivOrder: order of derivative (1, 2, ...)
	//     derivValue: explicit value, or null for Not-A-Knot
	//   }
	// RETURN VALUE
	//   returns a vector of points of interpolated curve
	function bsplineInterp(points, order, extraConditions)
	{
		var n = points.length;
		var p = order;
		
		// add multiplicity knots to begin and end
		var x = points.map(function(pt){return pt.x});
		//var y = points.map(function(pt){return pt.y});
		var xMin = x[0];
		var xMax = x[x.length-1];
		var xx = x.slice();
		for (var i = 0; i < p; i++) {
			xx.splice(0, 0, xMin);
			xx.push(xMax);
			//y.splice(0, 0, NaN);
			//y.push(NaN);
		}
		// Now:
		// x[0..p-1]   = multiplicity knots
		// x[p..p+n-1] = user-supplied real knots
		// x[p+n..p+n+p-1] = multiplicity knots
		
		// Compute the values of b-spline bases at user-supplied
		// knot points. There are (n+p-1) bases. The first basis
		// is always = 1 at the first point. The last basis is
		// always = 1 at the last point.
		
		// A vector of (n+p-1) coefficients, a[0..(n-1)+(p-1)],
		// are applied to the bspline bases. We need (n+p-1)
		// equations to solve these coeffcients. The first n
		// equations correspond to the user supplied knot
		// values. The rest (p-1) equations correspond to the
		// derivative conditions at selected knot points.
		
		var C = []; // (n+p-1)-by-(n+p-1) square matrix
		
		// First knot:
		C[0] = zeroVector(n+p-1);
		C[0][0] = 1.0;
		
		// Last knot:
		C[n-1] = zeroVector(n+p-1);
		C[n-1][n+p-2] = 1.0;
		
		// Interior knots: 
		for (var i = 1; i < n-1; i++) {
			// Each has exactly p non-zero bases.
			C[i] = zeroVector(n+p-1);
			for (var j = 0; j < p; j++) {
				C[i][i+j] = N(i+j,p,xx,x[i]);
			}
		}
		
		// Additional conditions:
		if (extraConditions.length != p - 1) {
			throw 'Wrong number of extra conditions.';
		}
		for (var k = 0; k < p - 1; k++) {
			var cond = extraConditions[k];
			var knotIndex = cond['knotIndex'];
			var derivOrder = cond['derivOrder'];
			var derivValue = cond['derivValue'];
			if (knotIndex < 0) {
				knotIndex += n;
			}
			if (!(knotIndex >= 0 && knotIndex < n)) {
				throw 'Invalid knot index: ' + knotIndex;
			}
			if (!(derivOrder >= 1 && derivOrder < p)) {
				throw 'Invalid order of derivative.';
			}
			// derivValue is ignored
			
			// The first knot and last knot has 2 non-zero
			// derivatives; the interior knots each has 3
			// non-zero derivatives. <- TBC
			C[n+k] = zeroVector(n+p-1);
			var i = knotIndex;
			for (var j = 0; j < p; j++) {
				C[n+k][i+j] = dN(i+j,p,xx,x[i],derivOrder);
			}
		}

		// Debug output.
		var invC = numeric.inv(C);
		$('#debugOutput').html(
			'<pre>'+numeric.prettyPrint(C)+'</pre>'+
			'<pre>Inverse</pre>' +
			'<pre>'+numeric.prettyPrint(invC)+'</pre>');
			
		// Compute the weights of bspline bases such that
		// the interpolated curve passes all the user-supplied
		// points and satisfies all the extra conditions.
		var y = points.map(function(pt){return pt.y});
		for (var k = 0; k < p - 1; k++) {
			y.push(extraConditions[k].derivValue);
		}
		var weights = numeric.dot(invC, y);
		
		// Given a grid of X values, compute their interpolated
		// values.
		var gridX = numeric.linspace(xMin, xMax, 200);
		var gridXY = [];
		for (var i = 0; i < gridX.length; i++) {
			var basisValues = [];
			// TODO: in fact we only need to sum (p+1) terms
			for (var j = 0; j < n+p-1; j++) {
				basisValues[j] = N(j,p,xx,gridX[i]);
			}
			gridXY.push({
				x: gridX[i],
				y: numeric.dot(weights, basisValues)
			});
		}
		return gridXY;
	}
	
	function zeroVector(length)
	{
		var v = [];
		for (var i = 0; i < length; i++) {
			v.push(0);
		}
		return v;
	}
	
	// Bezier basis function: N[i,n,a](u)
	// See the book
	function N(i, n, a, u)
	{
		if (n == 0) {
			//var leftContinuous = false;
			//if (leftContinuous)
			//	return (u > a[i] && u <= a[i+1])? 1 : 0;
			//else
			//	return (u >= a[i] && u < a[i+1])? 1 : 0;
			if (u >= a[i] && u < a[i+1])
				return 1;
			if (u == a[i+1] && a[i] < a[i+1] && a[i+1] == a[a.length-1])
				return 1;
			return 0;
		}
		var alpha1 = (a[i+n]-a[i]==0)? 0 : (u-a[i])/(a[i+n]-a[i]);
		var alpha2 = (a[i+1+n]-a[i+1]==0)? 0 : (u-a[i+1])/(a[i+1+n]-a[i+1]);
		return alpha1*N(i,n-1,a,u)+(1-alpha2)*N(i+1,n-1,a,u);
	}
	
	// Derivative of B-spline basis Bezier basis function: N[i,n,a](u)
	// See the book
	function dN(i, n, a, u, d)
	{
		if (d == 0) {
			return N(i, n, a, u);
		}
		if (n == 0) {
			return NaN;
		}
		var v1 = (a[i+n] - a[i] == 0)? 1 : (a[i+n] - a[i]);
		var v2 = (a[i+n+1] - a[i+1] == 0)? 1 : (a[i+n+1] - a[i+1]);
		return n/v1*dN(i,n-1,a,u,d-1)-n/v2*dN(i+1,n-1,a,u,d-1);
	}
	
  </script>
</head>

<body>
  <div>
    <div id="termStructureChart" style="width:100%; height:400px; border-width:1px; border-style:solid; border-color:black">
      [Term Structure]
    </div>
    <div id="debugOutput">[Debug]</div>
  </div>
</body>
</html>
