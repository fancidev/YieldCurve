<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <title>Hello</title>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jquery-1.11.3.min.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/canvasjs-1.8.0-beta4-mod.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jquery.canvasjs.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/numeric-1.2.6.js"></script>

  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jqwidgets/jqxcore.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jqwidgets/jqxbuttons.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jqwidgets/jqxscrollbar.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jqwidgets/jqxlistbox.js"></script>
  <script type="text/javascript" src="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jqwidgets/jqxdropdownlist.js"></script>
  <link rel="stylesheet" href="file:///e:/Dev/Repos/YieldCurve/YieldCurveDemo/jqwidgets/styles/jqx.base.css" type="text/css" />
  
  <script type="text/javascript">
$(function () {
	
	$("#termStructureChart").CanvasJSChart({
		title: {
			text: 'US Swap Rate Term Structure',
			fontSize: 16
		},
		legend: { 
			fontSize: 12,
		},
		axisX: {
			labelFontSize: 12,
			minimum: 0,
			gridThickness: 1,
			gridColor: 'gray',
			gridDashType: 'dash'
		},
		axisY: {
			labelFontSize: 12,
			gridThickness: 1,
			gridColor: 'gray',
			gridDashType: 'dash',
			labelFormatter: function (e) { return CanvasJS.formatNumber(e.value, '0.00'); }
		},
		toolTip: {
			shared: true
		},
		data: [ ]
	});
});

  </script>
  <script type="text/javascript">

	window.onerror = function () { return true; };

	$(document).ready(function () {
		var defaultPresetIndex = 0;
		
		$("#presetList").jqxDropDownList({
			source: splinePresets.map(function(p){return p.name;}), 
			selectedIndex: defaultPresetIndex, 
			width: 100, 
			height: 20,
			autoDropDownHeight: true,
			animationType: 'none',
		});
		$("#presetList").on('select', function (e) {
			if (e && e.args) {
				var index = e.args.index;
				drawTermStructure(splinePresets[index]);
			}
		});

		drawTermStructure(splinePresets[defaultPresetIndex]);
		//drawBumpResponse(splinePresets[defaultPresetIndex]);
		//drawBezierBasis();
	});
	
	// Plot each row in the table as a series.
	function drawBezierBasis() 
	{
		var chart = $("#termStructureChart").CanvasJSChart();
		var x = [-2,-1,0,  1,2,3,5,7,10,   11,12,13];
		x = [1,1,1,  1,2,3,5,7,10,   10,10,10];
		var np = x.length;
		chart.options.data.length = 0; // clear existing series
		var p = 3;
		for (var i = 0; i < x.length - p - 1; i++)
		{
			var dataPoints = [];
			var xx = [];
			var yy = [];
			for (var t = 1; t <= 10; t+=1/32) {
				xx.push(t);
				yy.push(N(i,p,x,t));
				dataPoints.push({
					x: t, y: N(i,p,x,t)
				});
			}
			chart.options.data.push({
				type: 'line',
				name: 'N_' + i + '^' + p,
				markerType: 'square',
				showInLegend: true,
				dataPoints: dataPoints
			});
		}
		
		for (var i = 0; i < x.length - p - 1; i++)
		{
			var dataPoints = [];
			var xx = [];
			var yy = [];
			for (var t = 1; t <= 10; t+=1/32) {
				xx.push(t);
				yy.push(dN(i,p,x,t,1));
				dataPoints.push({
					x: t, y: dN(i,p,x,t,1)
				});
			}
			chart.options.data.push({
				type: 'line',
				name: 'dN_' + i + '^' + p,
				markerType: 'square',
				showInLegend: true,
				dataPoints: dataPoints
			});
		}
		
		//adjustYAxisLimits(chart);
		chart.render();
	}
	
	var splinePresets = [
	{
		name: 'Linear',
		degree: 1,
		conditions: []
	},
	{
		name: 'Quadratic',
		degree: 2,
		conditions: [ 
			{ knotIndex: -1, derivOrder: 1, derivValue: 0 },
		]
	},
	{
		name: 'Cubic',
		degree: 3,
		conditions: [
			{ knotIndex:  0, derivOrder: 2, derivValue: 0 },
			{ knotIndex: -1, derivOrder: 2, derivValue: 0 },
		]
	},
	{
		name: 'Quartic',
		degree: 4,
		conditions: [
			{ knotIndex:  0, derivOrder: 2, derivValue: 0 },
			{ knotIndex: -1, derivOrder: 2, derivValue: 0 },
			{ knotIndex: -1, derivOrder: 1, derivValue: 0 },
		]
	},
	{
		name: 'Quintic',
		degree: 5,
		conditions: [
			{ knotIndex:  0, derivOrder: 2, derivValue: 0 },
			{ knotIndex: -1, derivOrder: 3, derivValue: 0 },
			{ knotIndex: -1, derivOrder: 2, derivValue: 0 },
			{ knotIndex: -1, derivOrder: 1, derivValue: 0 },			
		]
	}];
	
	var defaultDataPoints = [
		{ x: 0.25, y: 5.39 },
		{ x: 1, y: 5.39 },
		{ x: 2, y: 5.21 },
		{ x: 3, y: 5.16 },
		{ x: 4, y: 5.16 },
		{ x: 5, y: 5.18 },
		{ x: 7, y: 5.23 },
		{ x: 10, y: 5.29 },
		{ x: 30, y: 5.41 }
	];
		
	// Plot each row in the table as a series.
	function drawTermStructure(preset) 
	{
		var dataPoints = defaultDataPoints;
		
		var chart = $("#termStructureChart").CanvasJSChart();
		chart.options.data.length = 0; // clear existing series
		
		// Plot input data points.
		if (true) {
			chart.options.data.push({
				type: 'scatter',
				name: 'Term structure',
				markerType: 'square',
				showInLegend: true,
				dataPoints: dataPoints
			});
		}
		
		// Plot interpolated curve.
		if (true) {
			var XY = bsplineInterp(dataPoints, preset.degree, preset.conditions);
			chart.options.data.push({
				type: 'line',
				name: preset.name + ' Spline',
				markerType: 'none',
				showInLegend: true,
				dataPoints: XY
			});
		}
		
		adjustYAxisLimits(chart);
		chart.render();
		
		return;
		
		var chart = $("#termStructureChart").CanvasJSChart();
		chart.options.data.length = 0; // clear existing series
		chart.options.data.push({
			type: 'line',
			name: '08-SEP-2006',
			markerType: 'square',
			showInLegend: true,
			dataPoints: [
				{ x: 0.25, y: 5.39 },
				{ x: 1, y: 5.39 },
				{ x: 2, y: 5.21 },
				{ x: 3, y: 5.16 },
				{ x: 4, y: 5.16 },
				{ x: 5, y: 5.18 },
				{ x: 7, y: 5.23 },
				{ x: 10, y: 5.29 },
				{ x: 30, y: 5.41 }
			]
		});
		adjustYAxisLimits(chart);
		chart.render();
	}
	
	function drawBumpResponse(preset)
	{
		var dataPoints = defaultDataPoints;		
		var chart = $("#termStructureChart").CanvasJSChart();
		var XY = bsplineInterp(dataPoints, preset.degree, preset.conditions);
		
		// bump each point
		for (var i = 0; i < dataPoints.length; i++) {
			var bumpedDataPoints = dataPoints.slice();
			bumpedDataPoints[i] = {
				x: bumpedDataPoints[i].x,
				y: bumpedDataPoints[i].y + 0.01
			};
			var bumpedXY = bsplineInterp(bumpedDataPoints, preset.degree, preset.conditions);
			var diff = [];
			for (var j = 0; j < XY.length; j++) {
				diff[j] = {
					x: XY[j].x,
					y: (bumpedXY[j].y - XY[j].y) * 100
				};
			}
			chart.options.data.push({
				type: 'line',
				name: 'Bump ' + dataPoints[i].x + 'Y',
				markerType: 'none',
				showInLegend: true,
				dataPoints: diff
			});
		}
		adjustYAxisLimits(chart);
		chart.options.title.text = preset.name + ' Spline Response Curve';
		chart.options.toolTip.shared = false;
		chart.render();
	}
	
	function adjustYAxisLimits(chart)
	{
		var minY = Infinity;
		var maxY = -Infinity;
		var data = chart.options.data;
		for (var i = 0; i < data.length; i++) {
			var dataPoints = data[i].dataPoints;
			for (var j = 0; j < dataPoints.length; j++) {
				var value = dataPoints[j].y;
				minY = Math.min(minY, value);
				maxY = Math.max(maxY, value);
			}
		}
		
		// Adjust the Y-axis range to half-percent with 5bp margin.
		var margin = 0.05;
		var roundTo = 0.50;
		minY = Math.floor((minY - margin) / roundTo) * roundTo;
		maxY = Math.ceil((maxY + margin) / roundTo) * roundTo;
		chart.options.axisY.minimum = minY;
		chart.options.axisY.maximum = maxY;
		
		// Note: the caller must call chart.render() to take effect.
		// chart.render();
	}
	
	// Interpolate a vector of n points
	// { x: 1, y: 5.39 }, { x: 2, y: 5.21 }, ...
	// order:
	//   1 - linear
	//   2 - quadratic spline
	//   3 - cubic spline
	// extraConditions:
	//   An array of extra conditions to impose on the derivative
	//   on selected knot points. The number of conditions must be
	//   equal to (p - 1). Each condition is a named tuple:
	//   {
	//     knotIndex:  = zero-based knot index 
	//     derivOrder: order of derivative (1, 2, ...)
	//     derivValue: explicit value, or null for Not-A-Knot
	//   }
	// RETURN VALUE
	//   returns a vector of points of interpolated curve
	function bsplineInterp(points, order, extraConditions)
	{
		var n = points.length;
		var p = order;
		
		// add multiplicity knots to begin and end
		var x = points.map(function(pt){return pt.x});
		//var y = points.map(function(pt){return pt.y});
		var xMin = x[0];
		var xMax = x[x.length-1];
		var xx = x.slice();
		for (var i = 0; i < p; i++) {
			xx.splice(0, 0, xMin);
			xx.push(xMax);
			//y.splice(0, 0, NaN);
			//y.push(NaN);
		}
		// Now:
		// x[0..p-1]   = multiplicity knots
		// x[p..p+n-1] = user-supplied real knots
		// x[p+n..p+n+p-1] = multiplicity knots
		
		// Compute the values of b-spline bases at user-supplied
		// knot points. There are (n+p-1) bases. The first basis
		// is always = 1 at the first point. The last basis is
		// always = 1 at the last point.
		
		// A vector of (n+p-1) coefficients, a[0..(n-1)+(p-1)],
		// are applied to the bspline bases. We need (n+p-1)
		// equations to solve these coeffcients. The first n
		// equations correspond to the user supplied knot
		// values. The rest (p-1) equations correspond to the
		// derivative conditions at selected knot points.
		
		var C = []; // (n+p-1)-by-(n+p-1) square matrix
		
		// First knot:
		C[0] = zeroVector(n+p-1);
		C[0][0] = 1.0;
		
		// Last knot:
		C[n-1] = zeroVector(n+p-1);
		C[n-1][n+p-2] = 1.0;
		
		// Interior knots: 
		for (var i = 1; i < n-1; i++) {
			// Each has exactly p non-zero bases.
			C[i] = zeroVector(n+p-1);
			for (var j = 0; j < p; j++) {
				C[i][i+j] = N(i+j,p,xx,x[i]);
			}
		}
		
		// Additional conditions:
		if (extraConditions.length != p - 1) {
			throw 'Wrong number of extra conditions.';
		}
		for (var k = 0; k < p - 1; k++) {
			var cond = extraConditions[k];
			var knotIndex = cond['knotIndex'];
			var derivOrder = cond['derivOrder'];
			var derivValue = cond['derivValue'];
			if (knotIndex < 0) {
				knotIndex += n;
			}
			if (!(knotIndex >= 0 && knotIndex < n)) {
				throw 'Invalid knot index: ' + knotIndex;
			}
			if (!(derivOrder >= 1 && derivOrder < p)) {
				throw 'Invalid order of derivative.';
			}
			// derivValue is ignored
			
			// The first knot and last knot has 2 non-zero
			// derivatives; the interior knots each has 3
			// non-zero derivatives. <- TBC
			C[n+k] = zeroVector(n+p-1);
			var i = knotIndex;
			for (var j = 0; j < p; j++) {
				C[n+k][i+j] = dN(i+j,p,xx,x[i],derivOrder);
			}
		}

		// Debug output.
		var invC = numeric.inv(C);
		$('#debugOutput').html(
			'<pre>'+numeric.prettyPrint(C)+'</pre>'+
			'<pre>Inverse</pre>' +
			'<pre>'+numeric.prettyPrint(invC)+'</pre>');
			
		// Compute the weights of bspline bases such that
		// the interpolated curve passes all the user-supplied
		// points and satisfies all the extra conditions.
		var y = points.map(function(pt){return pt.y});
		for (var k = 0; k < p - 1; k++) {
			y.push(extraConditions[k].derivValue);
		}
		var weights = numeric.dot(invC, y);
		
		// Given a grid of X values, compute their interpolated
		// values.
		var gridX = numeric.linspace(xMin, xMax, 200);
		var gridXY = [];
		for (var i = 0; i < gridX.length; i++) {
			var basisValues = [];
			// TODO: in fact we only need to sum (p+1) terms
			for (var j = 0; j < n+p-1; j++) {
				basisValues[j] = N(j,p,xx,gridX[i]);
			}
			gridXY.push({
				x: gridX[i],
				y: numeric.dot(weights, basisValues)
			});
		}
		return gridXY;
	}
	
	function zeroVector(length)
	{
		var v = [];
		for (var i = 0; i < length; i++) {
			v.push(0);
		}
		return v;
	}
	
	// Bezier basis function: N[i,n,a](u)
	// See the book
	function N(i, n, a, u)
	{
		if (n == 0) {
			//var leftContinuous = false;
			//if (leftContinuous)
			//	return (u > a[i] && u <= a[i+1])? 1 : 0;
			//else
			//	return (u >= a[i] && u < a[i+1])? 1 : 0;
			if (u >= a[i] && u < a[i+1])
				return 1;
			if (u == a[i+1] && a[i] < a[i+1] && a[i+1] == a[a.length-1])
				return 1;
			return 0;
		}
		var alpha1 = (a[i+n]-a[i]==0)? 0 : (u-a[i])/(a[i+n]-a[i]);
		var alpha2 = (a[i+1+n]-a[i+1]==0)? 0 : (u-a[i+1])/(a[i+1+n]-a[i+1]);
		return alpha1*N(i,n-1,a,u)+(1-alpha2)*N(i+1,n-1,a,u);
	}
	
	// Derivative of B-spline basis Bezier basis function: N[i,n,a](u)
	// See the book
	function dN(i, n, a, u, d)
	{
		if (d == 0) {
			return N(i, n, a, u);
		}
		if (n == 0) {
			return NaN;
		}
		var v1 = (a[i+n] - a[i] == 0)? 1 : (a[i+n] - a[i]);
		var v2 = (a[i+n+1] - a[i+1] == 0)? 1 : (a[i+n+1] - a[i+1]);
		return n/v1*dN(i,n-1,a,u,d-1)-n/v2*dN(i+1,n-1,a,u,d-1);
	}
	
  </script>
</head>

<body>
  <div>
    <div>Spline: </div><div id="presetList"></div>
    <div id="termStructureChart" style="width:100%; height:400px; border-width:1px; border-style:solid; border-color:black">
      [Term Structure]
    </div>
    <div id="debugOutput">[Debug]</div>
  </div>
</body>
</html>
